/* 05: 25 - Какие атрибуты есть у тега script, для чего они ?
*async Устанавливает асинхронный режим исполнения скрипта, выполняется как загрузиться! Скрепты станут независимыми и не будут ждать друг друга! Должен не завистить от DOM , иначе ошибка!
*defer Устанавливает отложенный режим запуска скрипта, пока не будет загружена страница, в фоновом ружиме, скрипты запускаются по очереди в отличие от async
*charset Определяет кодировку символов скрипта
*src Определяет URL внешнего файла скрипта
*type Определяет медиа - тип скрипта*/
/* 08 : 15 - Какие типы данных есть в JavaScript ?
null.
undefined.
boolean.
number.
string.
object.
symbol.Это новый примитивный тип данных, как boolean или string, который нужен для 
	создания уникальных идентификаторов.
	Symbols— новый уникальный тип данных.Обычно используется как свойство объекта, чтобы не поломать Object.keys и
	for - in .
	Iterators— объект, который предоставляет метод next(), возвращающий следующий элемент последовательности.
	Обычно используется для кастомного перебора значений объектов в
	for - of и…(spread operator).
	Generators— hight level абстракция над итераторами.Обычно используется как низкоуровневая альтернатива
	async /await.
BigInt.это встроенный объект, который предоставляет способ представлять целые числа больше 2^53 - 1
*/
// 10 : 40 - Что верстал за все время изучения html / css ?
// 11 : 08 - Расскажи немного про BEM.
/*
Методология БЭМ— это список правил для фронтенд - проектов.Основные сущности, которыми оперирует БЭМ,
—блок, элемент и модификатор.
	Блок— это абсолютно независимый компонент страницы.Он отвечает только за отображение элементов— то есть,
например, у него не может быть внешних отступов margin.Блоки могут включать в себя другие блоки.Имя 
блока совпадает с именем селектора по классу:
	Элемент— это часть блока, которая имеет смысл только внутри своего блока и отдельно от него не используется.
Имя селектора включает имя класса и— через двойное подчёркивание— имя элемента.
	Модификатор— это сущность, которая описывает атрибуты блока или элемента: положение, состояние, поведение.
Для разделения слов в именах всех сущностей используются дефисы.Модификатор в селекторе именуется через одно
подчёркивание после имени элемента или блока.
		-Преимущества БЭМ
	1. Понятная структура проекта.Просто взглянув на названия селекторов, можно понять, как устроен проект и за
что отвечает тот или иной класс.
	2. Одновременная работа над разными компонентами.Правила именования обеспечивают уникальность селекторов,
вероятность повториться в именах модификаторов мала.Поэтому разработчики могут работать одновременно и
не создавать коллизий.
	3. Быстрый онбординг новых сотрудников.Изучение проекта требует меньше времени, потому что компоненты по 
БЭМ документируют сами себя.
	4. Высокая скорость разработки.Понятная структура облегчает рефакторинг, а возможность переиспользования— 
создание новых проектов.
	5. Безопасность при привлечении сторонних сотрудников.Проект строится из независимых блоков, поэтому каждому
задействованному разработчику знать подробности всего проекта не нужно.Специалисты могут работать в рамках
отдельных компонентов.Это позволяет привлекать сторонних специалистов на большие проекты.
	6. Гибкость.Можно применять не всю методологию, а только часть.И даже это может сделать работу над проектом удобнее.
		-Минусы БЭМ
	1. Использование блоков там, где можно обойтись без них.На небольших проектах код для маленьких компонентов
(например, логотипа или единственной кнопки), созданный в соответствии с принципами БЭМ, может выглядеть громоздко.
	2. Длинные имена элементов и модификаторов.Названия сущностей из нескольких слов могут серьёзно усложнить 
названия селекторов, и разработчику, не привыкшему к БЭМ, разбираться в них будет сложно.Поэтому при разработке 
приходится продумывать имена более тщательно, чтобы плюсы БЭМ не превращались в минусы.
	3. Необходимость знать БЭМ, чтобы работать с проектом и понимать принятую на проекте схему именования 
селекторов.Любые технологии требуют изучения, а именование в БЭМ поначалу может казаться избыточным.Но 
это тот случай, когда« лучше день потерять, потом за пять минут долететь».
	4. Расплывчатость понятия« по БЭМ».Обратная сторона гибкости БЭМ— сложно быстро объяснить, какие именно правила 
из методологии вы используете.
*/
// 15: 37 - Расскажи про z - index в css.
/*CSS-свойство z-index определяет положение позиционированного элемента и его дочерних элементов или
флекс-элементов по оси z. Перекрывающие элементы с большим значением z-index будут накладываться поверх 
элементов с меньшим z-index.*/
/* 16: 22 - Расскажи что такое JSON.
JSON(англ.JavaScript Object Notation)— текстовый формат обмена данными, основанный на JavaScript.Но 
при этом формат независим от JS и может использоваться в любом языке программирования.*/
// 18: 10 - Какая длина массива и что будет в console.log ?
const arr = [];
arr[0] = 'A';
arr['1'] = 'b';
arr.two = 'c';
arr[3] = 'd';
console.log(arr.length, arr)

// 23 : 56 - Вопрос про прототипы и proto.
function Creature(name) {
	this.name = name;
}
Creature.prototype.breath = function() {
	console.log(`${this.name} is breathing now`)
}
console.log(Creature.prototype === Creature.__proto__);
console.log(Creature.__proto__ === Function.prototype);
console.log(Creature.prototype);
console.log(Creature.__proto__);
console.log(Function.prototype);

const sam = new Creature('Sam');
sam.breath();
// 27: 48 - Создание переменных с var и без var, что выведется в консоль ?
// console.log(x);
// console.log(y);
y = 10;
var x = 20;

// 31 : 35 - Задача про очередь(https: //jsfiddle.net/mockinterview/dy...)
/*
Прислал Ruslan Yand.
Напишите функцию которая принимает первым аргументом массив
положительных, целых чисел, представляющий из себя очередь людей, где
каждый индекс массива это конкретный человек, а значение массива это
время которое будет затрачено на его обслуживание.
Вторым аргументом функция принимает количество касс, которые
обслуживают очередь людей.
Функция должна вернуть время, которое потребуется кассам для
обслуживания всей очереди.
Некоторые уточнения:
1. Количество касс всегда положительное целое число.
2. Количество людей в массиве может отсутствовать, но каждый человек всегда
имеет положительное целое число, обозначающее время обслуживания.
3. Порядок очереди НИКОГДА не меняется.
4. Первый человек в очереди (то есть первый элемент в массиве)
направляется к кассе, как только она становится свободой.
P.S. Ситуацию можно сравнить с идеей пула потоков, связанной с
одновременным запуском нескольких процессов.
*/
function queueTime(customers, n) {
	let time = 0;
	while (customers.length > 0) {
		(customers.length < n) && n--;
		if (!customers.includes(0)) {
			for (i = 0; i < n; i++) {
				customers[i]--;
			}
			time++;
		} else {
			const index = customers.indexOf(0);
			customers.splice(index, 1);
		}
	}
	return time;
 }
console.log(queueTime([5, 3, 4], 1)); // => 12
console.log(queueTime([10, 2, 3, 3], 2)); // => 10
console.log(queueTime([2, 3, 10], 2)); // => 12
console.log(queueTime([16, 14, 10, 3, 13, 9, 8, 19, 18, 20, 3, 7, 4, 16, 3], 6)); //=> 32

console.log(Array(2).fill(0)) // Array(2) создаст массив с 2-мя пустыми значениями, fill заполнит их 0
// решение студента супер!
function queueTime2(customers, n) {
	const q = Array(n).fill(0); // [0, 0]
	customers.forEach(c => {
		q.sort((a, b) => a - b)
		q[0] += c
	})
	return Math.max(...q)
}
console.log(queueTime2([5, 3, 4], 1)); // => 12
console.log(queueTime2([10, 2, 3, 3], 2)); // => 10
console.log(queueTime2([2, 3, 10], 2)); // => 12
console.log(queueTime2([16, 14, 10, 3, 13, 9, 8, 19, 18, 20, 3, 7, 4, 16, 3], 6)); //=> 32

// 44: 16 - Вопрос про прототипы№ 2. 
let personA = {};
let personB = {};
console.log(personA.__proto__ === personB.__proto__)
let A = {a: 'a'};
let B = ['a'];
console.log(A.__proto__ == B.__proto__) 
// 46: 14 - Задача с теговыми шаблонами(https: //jsfiddle.net/mockinterview/5u...)
/*
Необходимо реализовать printUser так, чтоб код ниже работал и выводил верный результат.
Код ниже менять нельзя.
*/
// const printer = ({name, age, surname}) => {
// 	let fullName = name;
// 	if (surname) {
// 		fullName = name + ' ' + surname;
// 	}
// 	return `Пользователь ${fullName}, возраст: ${age}`;
// }
function printUser(arr) {
	return function ({ name, age, surname}) {
		let fullName = name;
		if (surname) {
			fullName = name + ' ' + surname;
		}
		const str = `${arr[0]}${fullName}${arr[1]}${age}`
		let years = '';
		const lastNum = age.toString()[age.toString().length - 1];
		if (+lastNum === 1) { 
			years = ' год';
		} else if (+lastNum > 1 && +lastNum < 5) {
			years = ' года';
		} else {
			years = ' лет';
		}
		return str + years;
	}
}
const printer = printUser `Пользователь ${'fullName'}, возраст: ${'age'}`;
const user1 = {
	name: 'Павел',
	surname: 'Тарасов',
	age: 31
};
// Пользователь Павел Тарасов, возраст: 31 год
console.log(printer(user1));
const user2 = {
	name: 'Антон',
	age: 20
};
// Пользователь Антон, возраст: 20 лет
console.log(printer(user2));
const user3 = {
	name: 'Иван',
	surname: 'Иванов',
	age: 44
};
// Пользователь Иван Иванов, возраст: 44 года
console.log(printer(user3));

// 01: 14: 00 - Самая сложная задача(сарказм)(https: //jsfiddle.net/mockinterview/f2...)
/*
Прислал Purflix
На вход подается число value и n - количество знаков после запятой. 
Необходимо привести число к n знаков после запятой. 
Функция normalize должна возвращать строку.
*/
const normalize = (value, n) => {
	return value.toFixed(n).toString();
};
console.log(normalize(3.1415, 2)); // 3.14
console.log(normalize(0.5, 2)); // 0.50
console.log(normalize(2021, 0)); // 2021
console.log(normalize(0, 3)); // 0.000
console.log(normalize(1.1, 1)); // 1.1

// 01: 18: 04 - Работал с Map, Set ?


// 01 : 19: 17 - Что такое статические методы ?


// 01 : 24: 17 - Можем написать в js число с нижними подчеркиваниями ?
console.log(1_000_000)

// 01 : 27: 25 - Что скажешь про bind, что это такое ?


// 01 : 28: 40 - В чем разница forEach и map у массивов ?


// 01 : 28: 18 - Что на счет event loop ?


// 01 : 30: 48 - Что выведет и какой тип данных в выражении "2" - (-2) ?
console.log("2" - (-2))

// 01 : 33: 19 - Нужна ли программисту математика ?